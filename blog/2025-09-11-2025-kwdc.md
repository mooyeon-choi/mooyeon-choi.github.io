# 발표 정리 블로그 글 (상세 버전)

---

## 한글 정규화와 파일명 문제

한글은 **초성(ㄱ, ㄴ, …)**, **중성(ㅏ, ㅑ, …)**, \*\*종성(ㄱ, ㄹ, …)\*\*을 조합하여 문자를 형성합니다. 유니코드에서는 이를 표현하는 두 가지 방법이 있습니다.

- **NFC (Normalization Form C)**: ‘가’를 하나의 완성형 코드 포인트(U+AC00)로 저장
- **NFD (Normalization Form D)**: ‘가’를 초성(U+1100) + 중성(U+1161)으로 분해해 저장

이 차이는 운영체제에서 파일명 충돌 문제로 이어집니다.

- **macOS**: 기본적으로 NFD 사용 → ‘가’는 두 글자로 저장됨
- **Windows/Linux**: NFC 사용 → ‘가’는 하나의 코드로 저장됨

따라서 Dropbox, Google Drive 등 클라우드 동기화에서 같은 이름의 파일이 중복 생성되거나, 문자열 비교가 실패하는 경우가 발생합니다. Python, Swift 등 대부분 언어에서 제공하는 `normalize("NFC", text)`를 사용하면 문제를 예방할 수 있습니다.

---

## Swift 6와 레거시 스레드 API

Swift는 5.5부터 **async/await**과 **actor 모델**을 도입했습니다. Swift 6에서는 이 모델을 더욱 엄격히 적용하여, 레거시 스레드 기반 API(DispatchQueue, NSThread 등)와 충돌할 수 있습니다.

### Actor 경계 문제

actor는 상태를 격리해 동시 접근 문제를 방지하지만, 레거시 API는 이를 고려하지 않고 동기 호출을 수행합니다. 따라서 actor 메서드를 직접 호출하면 Swift 6에서 컴파일 오류가 발생합니다.

### 해결 방법 비교

1. **커스텀 Executor**: actor 실행을 특정 스케줄러(예: DispatchQueue)와 연결해 고성능 제어 가능하지만, 복잡한 구현이 필요합니다.
2. **DispatchQueue → Task 브리지**: `DispatchQueue.async { Task { await actor.method() } }` 방식으로 actor isolation을 안전하게 유지합니다. 일반 앱 개발에서 가장 권장됩니다.
3. **락 기반 접근**: NSLock이나 pthread_mutex를 활용해 상태를 보호합니다. 기존 코드를 최소 수정으로 유지할 수 있지만, Swift 동시성 철학에는 맞지 않으며 권장되지 않습니다.

---

## SharePlay & GroupActivities

**SharePlay**는 FaceTime 세션 중 앱의 콘텐츠(영상, 음악, 문서 등)를 동기화하는 기능이며, **GroupActivities**는 이를 지원하는 프레임워크입니다.

### 동작 흐름

1. GroupActivity 정의 (메타데이터 설정)
2. 사용자가 활동을 시작하고 다른 사람을 초대
3. 참여자 승인 → 세션 형성
4. 활동이 FaceTime을 통해 동기화 실행

### 도입 타당성

- **장점**: 학습, 피트니스, 공동 시청 경험에 적합
- **제약**: FaceTime 기반이므로 iOS/macOS에 종속, 네트워크 지연 문제 고려 필요

샘플 프로젝트를 통해 동작 원리를 익히면 실서비스 도입 여부를 객관적으로 판단할 수 있습니다.

---

## SE-0453 Inline Array

Swift의 표준 배열은 항상 Heap에 저장됩니다. 이로 인해 작은 배열도 불필요한 Heap 할당이 발생하고, 성능 저하와 캐시 미스 문제가 생깁니다.

**SE-0453 제안**은 **Inline Array**를 도입해 고정 크기 배열을 Stack에 저장하는 방식입니다.

- **효과**: 할당/해제 비용 감소, CPU 캐시 효율성 증가
- **활용 사례**: 좌표·벡터, 소규모 행렬 연산, 네트워크 패킷 헤더, IoT 센서 데이터 등

이 기능은 Swift가 성능 친화적인 언어로 발전하는 과정에서 중요한 이정표가 될 것으로 기대됩니다.

---

## Metal 렌더링 파이프라인

**Metal**은 Apple이 제공하는 저수준 GPU API로, 고성능 그래픽과 병렬 연산을 지원합니다.

### 파이프라인 구조

1. **Device**: GPU 추상화 객체
2. **Command Queue**: GPU 작업 제출 통로
3. **Buffer/Texture**: 입력 데이터
4. **Pipeline State**: 실행 규칙(셰이더, 픽셀 포맷 등)
5. **Command Buffer**: 하나의 실행 단위
6. **Drawable**: 화면 출력 대상

SwiftUI와 UIKit은 모두 `MTKView`를 통해 Metal을 통합할 수 있으며, 최신 Metal 4 API에서는 **Argument Buffers**와 **Mesh Shading**이 추가되어 복잡한 장면도 효율적으로 처리할 수 있습니다.

---

## 모바일 신원 (mDL & mdocs)

\*\*mDL(mobile Driving License)\*\*과 \*\*mdocs(mobile documents)\*\*는 운전면허증, 신분증 등 공인 문서를 모바일에 저장·활용할 수 있게 하는 기술입니다.

- **표준**: ISO/IEC 18013-5는 mDL을, ISO/IEC 23220 시리즈는 mdocs를 정의합니다.
- **Apple API**: PassKit 기반으로 앱 내 인증과 대면 인증을 지원합니다.

  - 앱 내 인증: 필요한 속성만 요청하고 Face ID/Touch ID로 승인
  - 대면 인증: NFC/QR 단말기와 Wallet을 연동

- **일본 사례**: 편의점 성인 인증, 행정 서비스 로그인 등에서 도입

이 기술은 금융, 모빌리티, 공공서비스에서 빠르게 확산될 가능성이 큽니다.

---

## Swift Testing과 런타임

Swift Testing은 XCTest의 한계를 보완하며, 런타임과 Mach-O 구조를 활용해 테스트 함수를 자동 수집합니다.

- **런타임 활용**: 함수 메타데이터를 탐색해 `@Test` 어노테이션이 붙은 함수 실행
- **Mach-O 구조**: 실행 파일 내 메타데이터 섹션에 테스트 정보 저장 → 런타임이 이를 불러 실행
- **응용**: 플러그인 아키텍처 구현, 코드 분석 도구 개발, DevOps 파이프라인 최적화

---

## Swift Container 생태계

Apple이 공개한 [apple/container](https://github.com/apple/container)는 데이터/리소스를 안전하게 캡슐화하는 Swift 패키지입니다.

- **구조**: Container → Key/Value → Backend (Memory/File/Cloud)
- **장점**: 통일된 API, Codable 직렬화 지원, 스토리지 전략 교체 용이
- **활용 분야**: 세션 관리, 앱 로컬 데이터 저장, 클라우드 연동, 단위 테스트

---

## AI as Apple & AI as Developer

- **Apple의 AI 전략**: 프라이버시 중심, 온디바이스 모델(Core ML, Neural Engine), UX 강화
- **개발자 관점**: 생산성 도구(Xcode), 앱 기능 강화(Core ML, Vision, Speech), SiriKit/Shortcuts 연계
- **교차점**: Apple은 인프라 제공, 개발자는 이를 활용해 신뢰성 있는 앱 경험 구현

---

## CellWalk 사례 (Apple Design Awards 파이널리스트)

CellWalk은 세포부터 원자까지 직관적으로 탐색할 수 있는 앱으로, Apple Design Awards 비주얼·그래픽 부문 파이널리스트에 선정되었습니다.

- **기술**: visionOS RealityKit + Metal, 멀티 스케일 시각화
- **UX 원칙**: 사용자 편안함 유지(높은 FPS), 복잡성 단순화(계층적 시각화), 직관적 제스처(시선 추적, 핀치 줌)
- **교육적 활용**: 생명과학·화학 학습, 연구 커뮤니케이션, K-12 교육

이 사례는 **공간 컴퓨팅과 교육**의 결합 가능성을 보여주는 대표적 예시입니다.

---

## 프로토타이핑과 앱 경험 개선

프로토타이핑은 사용자 중심 앱을 설계하는 필수 과정입니다.

- **저충실도 프로토타입**: 스케치, 와이어프레임 → 빠른 아이디어 검증
- **고충실도 프로토타입**: 실제 인터랙션·비주얼 포함 → 사용자 테스트에 활용
- **도구**: Figma, Sketch, Protopie, Xcode Previews

실제 사례에서 프로토타이핑은 로그인 플로우를 단순화하거나, 불필요한 단계를 제거해 사용자 만족도를 크게 높일 수 있습니다.

---

## LINE Plus ABC Studio 디자인 시스템 사례

소규모 팀(디자이너 1, 개발자 2)이 다음과 같은 접근으로 강력한 디자인 시스템을 구축했습니다.

- **토큰 구조**: Primitive → Semantic → Component 단계화로 일관성 확보
- **협업 도구**: Figma Variables와 Storybook 연계로 디자이너·개발자 간 소스 통합
- **멀티 테마 전략**: 테마 생성 23일 → 30분, 기능 디자인 34일 → 1일로 단축
- **성과**: 커뮤니케이션 비용 70% 절감, QA 시간 단축

핵심 교훈은 **시스템적 사고와 협업 언어**만 있으면 작은 팀도 큰 성과를 낼 수 있다는 점입니다.

---

## 결론

발표에서 다룬 다양한 주제(한글 정규화, Swift 동시성, SharePlay, Inline Array, Metal, 모바일 신원, Swift Testing, Container, AI, CellWalk, 프로토타이핑, 디자인 시스템)는 모두 서로 다른 영역이지만 공통된 메시지를 줍니다.

> **구조적 이해 + 시스템적 접근** → 성능, 보안, UX, 협업을 동시에 강화

개발자와 기획자는 이를 통해 더 나은 제품 경험과 효율적인 협업 환경을 만들어갈 수 있습니다.
