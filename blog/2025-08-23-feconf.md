---
slug: feconf2025
title: FECONF2025 톺아보기
authors: mooyeon
tags: [web, frontend]
date: 2025-08-23T12:00
---

# FECONF2025 톺아보기

## 소개

:::warning

🚧 내용 작성중

:::

FE conf 내용 정리

:::info 목차

1. [스벨트를 통해 리액트 더 잘 이해하기](#스밸트를-통해-리액트-더-잘-이해하기)
2. ['memo'를 지울결심: React Compiler가 제안하는 미래](#memo를-지울결심-react-compiler가-제안하는-미래)
3. [중요하지만 중요하지 않은 일, 그럼에도 계속해야하는 웹 접근성](#중요하지만-중요하지-않은-일-그럼에도-계속해야하는-웹-접근성)
4. [CSS in js]

:::

<!--truncate-->

## 스벨트를 통해 리액트 더 잘 이해하기

미세한 반응성(Fine-Grained Reactivity), DOM 조작 패턴, 그리고 트랜지션까지

프론트엔드 코드가 커질수록 <em>“필요한 부분만”</em> 계산·업데이트하는 능력이 중요해집니다. 스벨트(Svelte)는 컴파일 타임에 미세한 반응성(Fine-Grained Reactivity, 이하 FGR)을 녹여 넣고, 리액트(React)는 런타임의 선언적 모델과 메모이제이션으로 최적화를 유도합니다. 이 글은 스벨트의 관점으로 리액트를 다시 바라보며, FGR의 원리를 직접 구현·응용해 보는 실전 가이드입니다.

### 리렌더링 철학의 차이

#### 리액트: 상태 변경 → 컴포넌트 함수 재실행

리액트에서 useState의 값이 변하면 컴포넌트 함수 전체가 다시 호출됩니다. 필요한 부분만 실제 DOM 패치가 일어나도록 가상 DOM 비교와 메모이제이션이 도와주지만, 기본 규칙은 <em>“다시 호출”</em>이에요.

```js
import { useState } from "react";

export default function Example() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("Lee");

  return (
    <div>
      <div>count: {count}</div>
      <div>name: {name}</div>

      <button onClick={() => setCount((c) => c + 1)}>+1</button>
      <button onClick={() => setName((n) => n + "!")}>rename</button>
    </div>
  );
}
```

여기서 count만 바꿔도 함수는 통째로 재실행됩니다.

#### 스벨트: 사용된 곳만 업데이트 (컴파일러 주도 FGR)

스벨트는 컴파일 단계에서 “어떤 상태가 어디에서 쓰이는지”를 분석하여, 상태가 바뀔 때 그 상태를 참조한 DOM 조각만 갱신합니다. 스벨트 5의 룬(rune) 문법인 $state는 이 FGR을 아주 간단한 문법으로 노출합니다.

```js
<script>
  let count = $state(0);
  let name = $state("Lee");
</script>

<div>count: {count}</div>
<div>name: {name}</div>

<button on:click={() => (count = count + 1)}>+1</button>
<button on:click={() => (name = name + "!")}>rename</button>
```

상태 count만 바뀌면 해당 바인딩 영역만 갱신됩니다. “컴파일러가 의존성을 추출해 놓았다”라고 이해하면 편합니다.

### FGR란 무엇인가: 이펙트와 옵저버블의 뼈대

<strong>FGR(Fine-Grained Reactivity)</strong>는 값 단위로 의존성을 추적하고, 값이 바뀌면 그 값을 사용한 이펙트만 재실행하는 모델입니다.

핵심은 두 가지예요.

1. 옵저버블 값: get()과 set()을 가진 값 컨테이너
2. 이펙트: 실행 중 읽힌(get) 옵저버블을 자동 구독 → 그 값이 바뀌면 재실행

아래는 FGR의 최소 구현(컨셉 데모)입니다.

```js
// ── 최소 FGR 런타임 ─────────────────────────────────────────────
const ACTIVE_EFFECT_STACK = [];

export function observable(initial) {
  let value = initial;
  const subscribers = new Set();

  function get() {
    const active = ACTIVE_EFFECT_STACK[ACTIVE_EFFECT_STACK.length - 1];
    if (active) subscribers.add(active);
    return value;
  }

  function set(next) {
    if (Object.is(value, next)) return;
    value = next;
    subscribers.forEach((fn) => fn());
  }

  return { get, set };
}

export function effect(fn) {
  const runner = () => {
    try {
      ACTIVE_EFFECT_STACK.push(runner);
      fn(); // 실행 중에 읽힌(get) observable들이 이 이펙트를 자동 구독
    } finally {
      ACTIVE_EFFECT_STACK.pop();
    }
  };
  runner();
  return () => {
    // 간단 버전: 구독 해제 생략(실전은 필요시 구현)
  };
}
```

사용 예:

```js
const count = observable(0);
const name = observable("Lee");

effect(() => {
  console.log("count changed ->", count.get());
});

effect(() => {
  console.log("name changed ->", name.get());
});

count.set(1); // count 이펙트만 실행
name.set("Kim"); // name 이펙트만 실행
```

이것이 스벨트/솔리드(Solid) 계열 반응성의 핵심 아이디어입니다. _“그 값을 실제로 읽은 코드만 다시 돈다.”_

### 스벨트의 `$state`와 FGR

스벨트 5의 `$state`는 위 원리를 컴파일 타임에 자동 적용합니다. 의존성 추적은 런타임 코드가 아니라 <strong>컴파일러가 생성</strong>한 코드로 이뤄지므로, 런타임 오버헤드가 낮은 게 강점이죠. 결과적으로 <em>“문법은 간결, 동작은 세밀”</em>이 됩니다.

스벨트 컴파일 결과를 뜯어보면(요약) `count`를 읽는 자리에 업데이트 슬롯이 삽입·연결되고, `count = count + 1` 같은 대입 시 해당 슬롯만 갱신합니다. 즉, 위 미니 런타임에서 했던 의존성 그래프 생성·통지를 컴파일된 코드가 직접 수행합니다.

### 리액트에서 FGR은 불가능할까? (Legend-State 등으로 응용)

리액트 세계에서도 <strong>신호형 값(Observable/Signal)</strong>과 선택적 구독을 도입하면 FGR에 가까운 모델을 만들 수 있습니다. 예를 들어, 아래는 <strong>아주 작은 신호(signal)</strong>를 만들고, 컴포넌트가 그 신호만 구독하도록 하는 패턴입니다.

```js
// signal.ts
type Listener = () => void;

export function signal<T>(initial: T) {
  let value = initial;
  const subs = new Set<Listener>();

  return {
    get() {
      return value;
    },
    set(next: T) {
      if (Object.is(value, next)) return;
      value = next;
      subs.forEach((l) => l());
    },
    subscribe(l: Listener) {
      subs.add(l);
      return () => subs.delete(l);
    },
  };
}
```

```js
// useSignal.ts
import { useSyncExternalStore, useMemo } from "react";

export function useSignal<T>(sig: {
  get: () => T,
  subscribe: (l: () => void) => () => void,
}) {
  const getSnapshot = () => sig.get();
  const subscribe = (l: () => void) => sig.subscribe(l);
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
```

```js
// App.tsx
import { signal } from "./signal";
import { useSignal } from "./useSignal";

const count = signal(0);
const name = signal("Lee");

function Count() {
  const c = useSignal(count); // count만 구독
  return (
    <div>
      count: {c} <button onClick={() => count.set(c + 1)}>+1</button>
    </div>
  );
}

function Name() {
  const n = useSignal(name); // name만 구독
  return (
    <div>
      name: {n} <button onClick={() => name.set(n + "!")}>rename</button>
    </div>
  );
}

export default function App() {
  return (
    <>
      <Count />
      <Name />
    </>
  );
}
```

위 구조는 <strong>Count</strong>가 다시 그려져도 <strong>Name</strong>은 건드리지 않습니다. 반대로도 마찬가지. 즉, _“상태 단위로 의존성을 구독하는”_ FGR의 이점을 리액트에서도 누릴 수 있습니다.

> 참고: React 생태계에는 이러한 아이디어를 품은 서드파티 라이브러리(예: Legend-State 등)가 존재하며, React/React Native/Expo 프로젝트에서도 신호형 상태를 적용하는 선택지가 있습니다. 팀의 규모·취향에 따라 도입을 검토해 보세요.

### DOM 조작 패턴: 예시 _“밖을 클릭하면 닫기”_

#### (A) 전통적 훅 패턴

일반적으로는 `useRef` + `useEffect` + 전역 클릭 리스너로 구현합니다.

```js
import { useEffect, useRef, useState } from "react";

function useOnClickOutside(ref, handler) {
  useEffect(() => {
    function onClick(e) {
      if (!ref.current) return;
      if (!ref.current.contains(e.target)) handler(e);
    }
    document.addEventListener("mousedown", onClick);
    return () => document.removeEventListener("mousedown", onClick);
  }, [ref, handler]);
}

export default function Dropdown() {
  const ref = useRef(null);
  const [open, setOpen] = useState(false);
  useOnClickOutside(ref, () => setOpen(false));

  return (
    <div ref={ref}>
      <button onClick={() => setOpen((v) => !v)}>toggle</button>
      {open && <div className="menu">menu</div>}
    </div>
  );
}
```

단점: <em>“DOM에 어떤 로직이 붙는지”</em>가 <strong>컴포넌트 외곽</strong>으로 흩어져 있어 가독성이 떨어질 수 있어요.

#### (B) 스벨트: use: 디렉티브(액션)로 DOM에 직접 기능 부여

스벨트는 DOM 요소에 직접 “액션”을 붙입니다. 로직과 DOM이 한곳에 있어 직관적이에요.

```html
<script>
  export function clickOutside(node, handler) {
    function onClick(e) {
      if (!node.contains(e.target)) handler(e);
    }
    document.addEventListener('mousedown', onClick);
    return {
      destroy() {
        document.removeEventListener('mousedown', onClick);
      }
    };
  }

  let open = $state(false);
</script>

<div use:clickOutside={() => (open = false)}>
  <button on:click={() => (open = !open)}>toggle</button>
  {#if open}<div class="menu">menu</div>{/if}
</div>
```

#### (C) 리액트에 액션 패턴 이식: ref 콜백을 이용하자

리액트의 `ref`는 <strong>객체(ref.current)</strong>만 받는 게 아니라 <strong>함수(콜백)</strong>도 받을 수 있습니다. 이 콜백은 <strong>DOM 생성/소멸 시점</strong>에 호출되므로 스벨트의 `use:` 액션과 유사한 패턴을 만들 수 있습니다.

```js
// makeAction.tsx — 리액트용 "액션" 헬퍼
type Action<T extends Element> = (el: T) => void | (() => void);

export function makeAction<T extends Element>(action: Action<T>) {
  let cleanup: (() => void) | undefined;

  return (el: T | null) => {
    // el이 마운트될 때
    if (el && !cleanup) {
      const ret = action(el);
      cleanup = typeof ret === "function" ? ret : undefined;
    }
    // el이 언마운트될 때
    if (!el && cleanup) {
      cleanup();
      cleanup = undefined;
    }
  };
}
```

```js
// useOutside.tsx — 밖을 클릭하면 닫기
import { makeAction } from "./makeAction";

export function outside(action: (e: MouseEvent) => void) {
  return makeAction<HTMLElement>((node) => {
    const onClick = (e: MouseEvent) => {
      if (!node.contains(e.target as Node)) action(e);
    };
    document.addEventListener("mousedown", onClick);
    return () => document.removeEventListener("mousedown", onClick);
  });
}
```

```js
// Dropdown.tsx — 사용 예
import { useState } from "react";
import { outside } from "./useOutside";

export default function Dropdown() {
  const [open, setOpen] = useState(false);
  const attachOutside = outside(() => setOpen(false));

  return (
    <div ref={attachOutside}>
      <button onClick={() => setOpen((v) => !v)}>toggle</button>
      {open && <div className="menu">menu</div>}
    </div>
  );
}
```

이렇게 하면 <strong>DOM과 로직이 같은 위치</strong>에 있고, 생성/소멸 수명주기도 자연스럽게 처리됩니다. (React 19에서도 콜백 ref 패턴은 그대로 유효합니다.)

### 애니메이션/트랜지션: 등장·퇴장을 자연스럽게

#### 리액트의 현실과 한계

리액트는 요소를 조건부 렌더링에서 `false`/`null`이면 즉시 제거합니다. 그래서 _“퇴장 애니메이션 후 제거”_ 같은 동작에는 <strong>상태 지연</strong>이나 <strong>외부 라이브러리</strong>(Framer Motion 등)가 필요합니다.

#### 스벨트: 내장 트랜지션이 기본 제공

스벨트는 `transition:` 지시어로 쉽게 씁니다.

```html
<script>
  import { fade, fly } from 'svelte/transition';
  let open = $state(false);
</script>

<button on:click={() => (open = !open)}>toggle</button>

{#if open}
  <div transition:fade>간단 페이드</div>
  <div transition:fly={{ y: 10, duration: 150 }}>슬쩍 이동</div>
{/if}
```

커스텀 트랜지션도 함수로 만들 수 있어요. 함수는 `(node, params)`를 받아 `css` 또는 `tick`(매 프레임 호출)을 반환합니다.

```html
<script>
  function grow(node, { duration = 200 } = {}) {
    const h = node.offsetHeight;
    return {
      duration,
      css: (t) => `height: ${t * h}px; overflow: hidden;`
    };
  }
  let open = $state(false);
</script>

<button on:click={() => (open = !open)}>toggle</button>
{#if open}
  <div transition:grow>늘어나는 박스</div>
{/if}
```

#### 리액트에서 “퇴장 후 제거” 구현: Presence 훅(Web Animations API 버전)

외부 의존성을 줄인 소형 훅입니다. <strong>나갈 때 애니메이션</strong> → <strong>끝나면 unmount</strong> 흐름을 처리해요.

```js
// usePresence.ts
import { useEffect, useRef, useState } from "react";

type KeyframesOrFactory =
  | Keyframe[]
  | PropertyIndexedKeyframes
  | ((el: Element, mode: "in" | "out") => Keyframe[]);

export function usePresence(
  show: boolean,
  keyframes: KeyframesOrFactory,
  options?: KeyframeAnimationOptions
) {
  const [present, setPresent] = useState(show); // 실제로 렌더할지
  const modeRef = (useRef < "in") | ("out" > "in");
  const elRef = (useRef < HTMLElement) | (null > null);

  useEffect(() => {
    if (show) setPresent(true);
    modeRef.current = show ? "in" : "out";
  }, [show]);

  useEffect(() => {
    const el = elRef.current;
    if (!el) return;
    const frames =
      typeof keyframes === "function"
        ? keyframes(el, modeRef.current)
        : keyframes;
    const anim = el.animate(frames, {
      duration: 180,
      easing: "ease-out",
      fill: "both",
      ...options,
    });
    if (modeRef.current === "out") {
      anim.onfinish = () => setPresent(false);
    }
    return () => anim.cancel();
  }, [present, show, keyframes, options]);

  const ref = (node: HTMLElement | null) => {
    elRef.current = node;
  };

  return { present, ref };
}
```

```js
// FadeSlide.tsx — 사용 예
import { useState } from "react";
import { usePresence } from "./usePresence";

export default function Demo() {
  const [open, setOpen] = useState(false);
  const { present, ref } = usePresence(
    open,
    (el, mode) =>
      mode === "in"
        ? [
            { opacity: 0, transform: "translateY(6px)" },
            { opacity: 1, transform: "translateY(0)" },
          ]
        : [
            { opacity: 1, transform: "translateY(0)" },
            { opacity: 0, transform: "translateY(6px)" },
          ],
    { duration: 200 }
  );

  return (
    <div>
      <button onClick={() => setOpen((v) => !v)}>toggle</button>
      {present && (
        <div ref={ref} style={{ willChange: "opacity, transform" }}>
          부드러운 등장/퇴장
        </div>
      )}
    </div>
  );
}
```

리액트에서도 <strong>DOM 생성/소멸 시점을 잡아</strong> 적절한 애니메이션을 적용하면 스벨트 내장 트랜지션과 거의 같은 UX를 낼 수 있습니다. (규모가 커지면 Framer Motion, React Transition Group 등도 실전에서 훌륭한 선택지예요. 다만 위처럼 “핵심 로직을 직접 이해한 뒤” 라이브러리를 쓰는 것이 유지보수에 유리합니다.)

#### 메모 컴포넌트 패턴에 FGR 접목

리액트에서 `memo`, `useMemo`, `useCallback`은 <strong>불필요한 재실행을 줄이는 기본 도구</strong>입니다. 여기에 <strong>신호형 상태</strong>(위 signal 예시)를 결합하면, <em>“컴포넌트는 작게 쪼개고, 각 컴포넌트는 필요한 신호만 구독”</em>하는 구조를 손쉽게 만들 수 있습니다.

```js
import { memo } from "react";
import { signal } from "./signal";
import { useSignal } from "./useSignal";

const price = signal(100);
const qty = signal(1);

const Total = memo(function Total() {
  const p = useSignal(price);
  const q = useSignal(qty);
  return <div>Total: {p * q}</div>;
});

const Qty = memo(function Qty() {
  const q = useSignal(qty);
  return <button onClick={() => qty.set(q + 1)}>+1</button>;
});

export default function Cart() {
  return (
    <>
      <Total />
      <Qty />
    </>
  );
}
```

이 패턴은 <strong>의존성 단위로만 다시 그림</strong>을 보장합니다. 렌더 트리 규모가 커질수록 차이가 눈에 띱니다.

### 마무리: 스벨트로 보는 리액트, 리액트로 배우는 스벨트

- 스벨트는 컴파일러가 FGR을 자동 생성하므로, 문법이 간결하고 기본이 빠릅니다.

- 리액트는 런타임 선언 모델을 취하지만, 신호형 상태 + 선택적 구독 + 콜백 ref 같은 패턴을 도입하면 FGR의 이점을 상당 부분 흉내 낼 수 있습니다.

- DOM 액션 패턴, 등장/퇴장 트랜지션도 <strong>“생성/소멸 시점”과 “의존성 단위”</strong>를 잘 잡아주면 두 프레임워크 모두에서 일관된 설계를 만들 수 있습니다.

:::note 참고

스벨트의 FGR 감각을 유지한 채 리액트/리액트 네이티브/Expo 프로젝트에서도 신호형 상태를 쓰고 싶다면, Legend-State처럼 신호·스토어·파생값을 제공하는 경량 라이브러리를 검토해 보세요. 팀 합의와 DX(디버깅, DevTools)도 함께 고려하는 것이 좋습니다.

:::

### 부록: 새 useOutside(콜백 ref 기반) – 최종 형태

```ts
// useOutside.tsx
import { useCallback } from "react";

type Options = {
  event?: "mousedown" | "click" | "pointerdown";
  enabled?: boolean;
};

export function useOutside(onOutside: (e: Event) => void, opts: Options = {}) {
  const { event = "mousedown", enabled = true } = opts;

  const ref = useCallback(
    (node: HTMLElement | null) => {
      if (!enabled || !node) return;

      const onEvt = (e: Event) => {
        if (!node.contains(e.target as Node)) onOutside(e);
      };

      document.addEventListener(event, onEvt);
      return () => {
        document.removeEventListener(event, onEvt);
      };
    },
    [onOutside, event, enabled]
  );

  return ref; // <div ref={ref}> 에 바로 꽂아서 사용
}
```

```ts
// 사용
function Menu() {
  const [open, setOpen] = useState(false);
  const ref = useOutside(() => setOpen(false), { event: "pointerdown" });

  return (
    <div ref={ref}>
      <button onClick={() => setOpen((v) => !v)}>toggle</button>
      {open && <div className="menu">menu</div>}
    </div>
  );
}
```

## 'memo'를 지울결심: React Compiler가 제안하는 미래

> “언제 `memo`, `useMemo`, `useCallback`을 써야 하죠?”<br/>
> React Compiler의 대답은 간단합니다. <strong>“대부분의 경우, 신경 쓰지 마세요.”</strong>

### React Compiler란?

- 초기 **React Forget**으로 연구가 시작되어, **React Conf 2024** 무대에서 정식으로 공개된 컴파일러 기반 최적화입니다.
- 목표는 **수동 메모이제이션** 걱정을 줄이고, React의 룰을 잘 지키면 **컴파일러가 자동으로 연산을 캐싱/스킵**하게 만드는 것입니다.

### 리액트의 기본 특성 다시 보기

#### 부모가 리렌더되면, 자식도 리렌더된다

리액트는 상태 변경 시 **컴포넌트 함수가 재호출**됩니다. 부모가 다시 실행되면 자식도 다시 실행되는 것이 기본 규칙이죠.

#### 그래서 지금까지는 수동 메모이제이션을 했다

`memo`, `useMemo`, `useCallback`으로 **불필요한 재실행**과 **재생성**을 막아왔습니다. 하지만 “어디에, 어느 정도로 쓰느냐”가 항상 고민거리였죠

#### 모든 곳에 다 쓰면 좋을까? → No

- 오버헤드(의존성 배열 관리, 코드 부피 증가)
- 가독성 저하(본질 로직이 최적화 코드에 파묻힘)
- 버그 위험(의존성 누락/과잉)

### 수동 메모이제이션의 한계 → React Compiler 등장

React Compiler는 **코드를 분석하여 자동으로 메모이제이션 지점을 삽입**합니다. 즉, 개발자는 <strong>React의 규칙(Rules of React)</strong>을 지키며 로직을 쓰면 되고, **최적화는 컴파일러가 책임**지는 방향으로 진화합니다.

### 컴파일러는 실제로 무엇을 하나?

> 아래 코드는 이해를 위한 의사 코드입니다(실제 내부 구현과 다를 수 있음).

#### (1) 캐시 슬롯을 만드는 내부 훅: useMemoCache(size)

컴파일러는 컴포넌트마다 “필요한 캐시 슬롯 개수”를 계산해 두고, **Fiber 노드에 배열 형태로 저장**합니다.

```js
// 원본 (개념)
function Text({ color }) {
  const style = { color }; // 매 렌더마다 객체 생성
  return <span style={style}>Hello</span>;
}
```

```js
// 컴파일 후 의사 코드
function Text_compiled({ color }) {
  const $ = useMemoCache(1); // 캐시 슬롯 1개 확보
  let style;

  // 첫 렌더: 캐시 미존재 → 계산 후 저장
  if ($[0] === undefined || $[0].**key !== color) {
    style = { color };
    $[0] = { **key: color, **val: style }; // 심볼/키로 동일성 추적
  } else {
    style = $[0].\*\*val; // 캐시 재사용
  }

  return <span style={style}>Hello</span>;
}
```

핵심 아이디어:

- <strong>리액티브 값(시간에 따라 변할 수 있는 값)</strong>을 기준으로 동일성 체크 키를 만들고, **변하지 않았다면 재계산/재생성을 건너뜀**.

#### (2) 조건 분기에서도 분기별 캐시를 둔다

```js
// 원본
function Badge({ variant }) {
  if (variant === "success") {
    const s = { background: "green", color: "white" };
    return <span style={s}>OK</span>;
  } else {
    const s = { background: "gray", color: "black" };
    return <span style={s}>NG</span>;
  }
}
```

```js
// 컴파일 후 의사 코드
function Badge_compiled({ variant }) {
  const $ = useMemoCache(2); // 각 분기에 1칸씩
  if (variant === "success") {
    if ($[0] === undefined) $[0] = { background: "green", color: "white" };
    return <span style={$[0]}>OK</span>;
  } else {
    if ($[1] === undefined) $[1] = { background: "gray", color: "black" };
    return <span style={$[1]}>NG</span>;
  }
}
```

분기 전환이 일어나지 않는 한,** 각 분기에서 한 번 만든 객체를 계속 재사용**합니다.

#### (3) 부모 상태 추가 → 자식 재계산? 컴파일러가 막아준다

```js
function App() {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <Text color="tomato" /> {/_ 여기 안의 style 계산을 스킵 _/}
    </>
  );
}
```

부모가 리렌더되어도 `Text`의 리액티브 키(여기선 `color`)가 변하지 않으면, 컴파일러는 **자식 내부의 비싼 연산/생성**을 자동으로 스킵하도록 변환합니다.

### “컴파일러”의 분석 파이프라인 한눈에

> “컴파일이냐 트랜스파일이냐?” 용어는 중요하지 않습니다. 핵심은 고수준 React 코드를 분석하여 저수준 형태(HIR 등)로 바꿔 최적화 정보를 주입한 뒤 다시 JS로 방출한다는 점.

1. 파싱(AST)
   Babel 등으로 소스 코드를 <strong>AST(Abstract Syntax Tree)</strong>로 변환.

2. HIR(High-level IR) 작성
   AST가 구문 구조라면, HIR은 <strong>실행 흐름 단위(블록/엣지)</strong>를 표현.

- 블록: 실행 단위
- 엣지: 블록 간 제어 흐름

3. SSA(Static Single Assignment)

   - 변수에 단 한 번만 할당되도록 재작성(버저닝).
   - 재할당을 버전으로 관리하면 데이터 흐름 분석이 쉬워짐.

4. Reactive 분석

- “시간에 따라 변할 수 있는 값(리액티브 값)”을 식별:
  - props/함수 파라미터(부모가 언제든 바꿀 수 있음)
  - 훅 호출 결과(useState, useContext, useSelector 등)
  - 전역/외부 상태 접근 값
  - 위에서 파생된 값(계산 결과)

5. Reactive 스코프 형성

- 리액티브 값의 <strong>영향 범위(스코프)</strong>를 그룹화.
- 각 스코프 경계에 캐시 슬롯과 키 비교 로직을 배치.

6. JS로 방출

- 내부 HIR/스코프 정보를 반영하여 컴파일된 React 코드를 출력.
- 결과적으로 개발자가 직접 쓰지 않아도 <strong>“조건부/분기별 캐싱”</strong>이 자동 삽입됨.

### 개발자 입장에서 느껴질 변화

✅ 좋은 소식

- “여기 useMemo 필요할까?” 고민이 크게 줄어듦
- 분기별 캐시처럼 사람이 손으로 하기 번거로운 최적화를 자동으로

⚠️ 그래도 지켜야 할 것(낙관적 가정의 비용)

컴파일러는 <string>React의 규칙(Rules of React)</string>이 지켜진다는 **낙관적 가정** 하에 동작합니다.
규칙 위반(순수성 깨짐, 랜더 중 부수효과, 훅 순서 변경 등)은 <string>에러가 아닌 “오동작”</string>으로 나타날 수 있어요.

- 대처 방법
  - ESLint + React 플러그인을 켜고, 경고를 없앨 것
  - 부수효과는 useEffect로 옮기고, 렌더는 순수하게
  - 안정성 보강 도구: react-forgive(experimental) — LSP 기반으로 컴파일 추론을 노출/보조

📦 번들 크기 주의

- 컴포넌트 단위로 변환 코드가 추가됩니다.
- 리액티브 값/분기가 많을수록 코드량이 증가할 수 있습니다.
- 간단 예제에서 2.28배 늘어난 사례가 보고되지만(예시), 실제 수치는 코드베이스/코드스플리팅 여부에 따라 다릅니다.
  → 코드스플리팅과 불필요한 리액티브 값 최소화가 여전히 중요.

### 새 멘탈 모델: React as a Language

React를 “라이브러리”라기보다 언어처럼 생각하면 컴파일러와 궁합이 좋아집니다.

1. 룰을 엄격히 준수

- 렌더는 순수 함수처럼: 동등 입력 → 동등 출력
- 훅은 탑레벨에서 동일 순서로 호출
- 부수효과는 Effect 계층으로

2. “변하는 값”을 선명히 파악

- 무엇이 리액티브인지(언제/어디서 바뀌는지) 의식적으로 구분
- 변하지 않는 값은 상수/모듈 상단 등으로 탈리액티브화.

3. 조건 분기 = 스코프 분리

- `if (variant === 'a')`처럼 분기가 명확하면, 각 분기에서 별도 캐시가 자리 잡아 이득을 봄.

### 실전 예제로 보는 “값의 변화 흐름”과 캐시

#### (A) “직전값과 비교”가 핵심

```js
function ColorText({ color }) {
  const style = { color }; // 컴파일러가 color를 키로 캐시
  return <span style={style}>Hi</span>;
}
```

- `color`가 같으면 **style 재생성**은 스킵.

#### (B) 순회/정렬 같은 비싼 연산도 자동 스킵

```js
function List({ items, sort }) {
  // sort가 바뀌지 않으면 정렬 결과 캐시를 재사용
  const sorted = [...items].sort(sort);
  return (
    <ul>
      {sorted.map((i) => (
        <li key={i.id}>{i.name}</li>
      ))}
    </ul>
  );
}
```

#### (C) 분기별로 “캐시 하나씩”

```js
function PriceTag({ currency, amount }) {
  if (currency === "KRW") {
    const text = new Intl.NumberFormat("ko-KR").format(amount);
    return <span>{text}원</span>;
  } else {
    const text = new Intl.NumberFormat("en-US", {
      style: "currency",
      currency,
    }).format(amount);
    return <span>{text}</span>;
  }
}
```

- KRW 분기에서 만든 `text`는 KRW 분기에 캐시,
- USD/JPY 등 다른 분기는 **각각의 캐시**를 가짐.

#### (D) 리액티브 값의 중첩과 캐시 전략

1. 하나의 캐시에 몰아넣는 경우:

- “들어올 값 종류를 예측하기 어렵다”면 범용 캐시 1개로, **키(파생값 조합)**로 구분.

2. 분기별로 쪼개는 경우:

- `if/else`, `switch` 등 스코프가 명확하면 분기마다 캐시 슬롯을 갖게 되어 더 미세하게 스킵.

## 중요하지만 중요하지 않은 일, 그럼에도 계속해야하는 웹 접근성

웹접근성

https://frontend.moe

웹 접근성이 무엇이고 어떻게 지원을 하는지

평소 고려했던 웹 접근성의 가치와 알게된 내용 공유

웹 접근성이란

접근성 지원은 늘 고려하는 사용자 중심 디자인의 다른 관점으로 해석할 수 있음

때로는 심미성 보다 접근성 고려가 우선

ARIA 란?

시멘틱 태그의 중요성 언급

웹 접근성이 UI 설계에 중요한 이유 ARIA css 규칙 설계 내용

## css in js

react server components 로 인해 css in js 의 사용량 감소

개선하려 했지만 'use client' 를 추가한 방법으로 근본적으로 해결할 수 없음

kuma ui panda css -< zero runtime css

## 1년에 10억 원을 절약한, 강남언니의 SEO 웹 전략 공개

## Tanstack query를 넘어 향해! 쿼리를 라우터까지 전파시키기

RSC 살펴보기

클라이언트까지 도달하지 않는 컴포넌트

서버자원을 효과적으로 사용ㅇ 서버환경동작

내부에서 비동기 연산 사용ㅇ

자식요소로 클라이언트 컴포넌트 사용가능

클라이언트 미도달?

전통적 ssr구조

spring ror flask 미리 html 로딩 후 클라이언트에서 그려줌

isomorphic component 서버와 클라인언트를 동일한 환경으로 하자

react server components 다시 분리

서버 자원 사용ㅇ

서버만 알고있는 정보를 분리하기 위해

서버자원 사용ㅇ

getServerSideProps 프레임워크에서 독립한 모든 리액트 프레임워크에서 사용하도록

컴포넌트 단위 ssg/ssr/isr의 시대

비동기 연산

hooks 대신 비동기 연산 사용

rule of hooks 는 이제 없다

await promise.all() 같은 함수를 편하게 사용

tanstack query로 rsc 제대로 사용

advanced server rendering 에서는

## 모노레포 절망편, 14개의 레포로 부활하기까지 걸린 1년

의존성 시각화 툴 찾아보기
