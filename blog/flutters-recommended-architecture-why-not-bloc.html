<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.1">
<title data-rh="true">Flutter 권장 아키텍쳐, BLoC은 왜 안될까? | Mylog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Flutter 권장 아키텍쳐, BLoC은 왜 안될까? | Mylog"><meta data-rh="true" name="description" content="소개"><meta data-rh="true" property="og:description" content="소개"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-12-16T09:12:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/mooyeon-choi"><meta data-rh="true" property="article:tag" content="flutter,Architecture,bloc,design pattern"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc"><link data-rh="true" rel="alternate" href="https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc" hreflang="ko"><link data-rh="true" rel="alternate" href="https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc","mainEntityOfPage":"https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc","url":"https://mooyeon-choi.github.io/blog/flutters-recommended-architecture-why-not-bloc","headline":"Flutter 권장 아키텍쳐, BLoC은 왜 안될까?","name":"Flutter 권장 아키텍쳐, BLoC은 왜 안될까?","description":"소개","datePublished":"2024-12-16T09:12:00.000Z","author":{"@type":"Person","name":"Mooyeon Choi","url":"https://github.com/mooyeon-choi","image":"https://github.com/mooyeon-choi.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://mooyeon-choi.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Mylog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Mylog Atom Feed">




<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script><link rel="stylesheet" href="/assets/css/styles.52db5588.css">
<script src="/assets/js/runtime~main.41d202ba.js" defer="defer"></script>
<script src="/assets/js/main.1cfb6896.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.png" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Mylog</b></a><a class="navbar__item navbar__link" href="/docs/intro">개발 공부</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">기록</a><a class="navbar__item navbar__link" href="/showcase">Showcase</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://www.canva.com/design/DAGz-nqnzUs/hqoQlPIJGeUcR_Zt0MYSRA/view?utm_content=DAGz-nqnzUs&amp;utm_campaign=designshare&amp;utm_medium=link2&amp;utm_source=uniquelinks&amp;utlId=h675136036a" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Resume<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://www.canva.com/design/DAG0FtTtc7Q/5bxilRwjMyASzdWmJYeuIA/watch?utm_content=DAG0FtTtc7Q&amp;utm_campaign=designshare&amp;utm_medium=link2&amp;utm_source=uniquelinks&amp;utlId=he3cc71b0d4" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Portfolio<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://open.kakao.com/o/sEenYDXg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">CoffeeChat<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><a href="https://github.com/mooyeon-choi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2025-kwdc">2025 KWDC 톺아보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/feconf2025">FECONF2025 톺아보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/onnx-on-web">Onnx web runtime 구축하기 with Vite</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/eslint-with-tailwindcss">왜 eslint-plugin-tailwindcss 를 버리고 eslint-plugin-better-tailwindcss 를 새로 개발하였을까?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/service-worker">Web Service Worker로 파일 업로드 분리하기</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">Flutter 권장 아키텍쳐, BLoC은 왜 안될까?</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-12-16T09:12:00.000Z">2024년 12월 16일</time></div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/mooyeon-choi" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/mooyeon-choi.png" alt="Mooyeon Choi"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/mooyeon-choi" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp" translate="no">Mooyeon Choi</span></a></div><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="소개">소개<a href="#소개" class="hash-link" aria-label="소개에 대한 직접 링크" title="소개에 대한 직접 링크" translate="no">​</a></h2>
<p>최근(2024년 12월) Flutter 팀은 아키텍쳐 가이드를 게시하고 네이티브 Kotlin, Swift와 같은 다른 모바일 프레임워크에서 채택한 확립된 패턴을 따라 Flutter 앱의 레이어를 구성하는데 MVVM 접근 방식을 사용할 것을 제안했다. 이때 MVVM 접근 방식으로 사용한다면 기존에 많은 개발자들이 사용 중이던 BLoC의 접근 방식이 떠올릴 수 있다. 그렇다면 왜 Flutter에서는 BLoC의 사용을 권장하지 않고 다시 제안을 하였을까?</p>
<p>이 글은 <a href="https://empires.medium.com/flutters-recommended-architecture-why-not-bloc-6cccc1d078d3" target="_blank" rel="noopener noreferrer">Flutter’s recommended architecture: why not BLoC? - Eduardo Pires, Medium Blog</a>의 글을 의역하며 내가 이해한 내용을 정리한 글이다.</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>목차</div><div class="admonitionContent_BuS1"><ol>
<li><a href="#%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD-%EC%9D%B4%ED%95%B4">기본 사항 이해</a></li>
<li><a href="#%EC%A0%95%EB%A6%AC">정리</a></li>
</ol></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="기본-사항-이해">기본 사항 이해<a href="#기본-사항-이해" class="hash-link" aria-label="기본 사항 이해에 대한 직접 링크" title="기본 사항 이해에 대한 직접 링크" translate="no">​</a></h2>
<p><strong>BLoC(Business Logic Component)</strong> 은 <strong>상태</strong>와 <strong>이밴트</strong>를 관리하기 위해 <strong>Streams</strong>을 사용하는 반응형 프로그래밍 패러다임을 따른다. BLoC의 주요 목표는 비즈니스 로직을 UI와 완전히 분리하는 단방향 데이터 흐름을 적용하는 것이다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bloc의-주요-구성요소">BLoC의 주요 구성요소<a href="#bloc의-주요-구성요소" class="hash-link" aria-label="BLoC의 주요 구성요소에 대한 직접 링크" title="BLoC의 주요 구성요소에 대한 직접 링크" translate="no">​</a></h3>
<ol>
<li><strong>Events</strong>: 사용자 작업이나 외부 트리거.</li>
<li><strong>States</strong>: UI의 현재 상태</li>
<li><strong>Blocs</strong>: 스트림을 사용하여 이벤트를 상태에 매핑</li>
</ol>
<p><img decoding="async" loading="lazy" alt="Bloc Architecture" src="/assets/images/bloc_architecture-50bc772dcbe86a9eb5d138977af302dd.webp" width="1400" height="370" class="img_ev3q">
MVVM 계층 아키텍처( <a href="https://docs.flutter.dev/app-architecture/concepts" target="_blank" rel="noopener noreferrer">https://docs.flutter.dev/app-architecture/concepts</a>)</p>
<p>반면, MVVM(Model-View-ViewModel) 패턴은 상태를 관리하는 더 간단한 방법을 제공한다. 여기서 ViewModel은 UI(View)와 데이터(Model) 사이의 중개자 역할을 한다. 이때, <code>notifyListeners()</code> 메서드를 사용하여 UI에 변경사항을 알린다.</p>
<p><img decoding="async" loading="lazy" alt="MVVM Architecture" src="/assets/images/mvvm_architecture-809f998e84bfc2c8ba0ee1bba58bba72.webp" width="1400" height="249" class="img_ev3q">
MVVM 계층 아키텍처( <a href="https://docs.flutter.dev/app-architecture/concepts" target="_blank" rel="noopener noreferrer">https://docs.flutter.dev/app-architecture/concepts</a>)</p>
<p>두 구조를 확인했을 때 유사한 점을 확인할 수 있다. 둘 모두 상태를 효율적으로 관리하고 UI를 반응적으로 업데이트하는 것을 목표로 하며, 둘 다 Flutter 위젯과 완벽하게 통합되고 비동기 작업을 지원한다. 하지만 BLoC의 Streams는 보다 복잡한 워크플로우에 더 적합하다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mvvm의-주요-구성요소">MVVM의 주요 구성요소<a href="#mvvm의-주요-구성요소" class="hash-link" aria-label="MVVM의 주요 구성요소에 대한 직접 링크" title="MVVM의 주요 구성요소에 대한 직접 링크" translate="no">​</a></h3>
<ol>
<li><strong>Model</strong>: 앱의 데이터를 나타낸다.</li>
<li><strong>ViewModel</strong>: 상태와 비즈니스 로직을 관리한다.</li>
<li><strong>View</strong>: UI를 표시하고 변경 사항을 관찰한다.</li>
</ol>
<p><img decoding="async" loading="lazy" alt="MVVM Architecture 1" src="/assets/images/mvvm_architecture_1-5cce0b6f783eb44074c9e9d265042f04.webp" width="1400" height="263" class="img_ev3q">
MVVM 접근 방식의 구성 요소( <a href="https://docs.flutter.dev/app-architecture/guide" target="_blank" rel="noopener noreferrer">https://docs.flutter.dev/app-architecture/guide</a>)</p>
<p>이 둘은 주로 관심사를 잘 정의된 계층적 아키텍처로 분리한다는 동일한 아이디어에 기반을 두고 있으므로, 아래의 내용에서 둘 사이의 차이점에 초점을 맞춰보자.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="주요-차이점">주요 차이점<a href="#주요-차이점" class="hash-link" aria-label="주요 차이점에 대한 직접 링크" title="주요 차이점에 대한 직접 링크" translate="no">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-데이터-흐름">1. 데이터 흐름<a href="#1-데이터-흐름" class="hash-link" aria-label="1. 데이터 흐름에 대한 직접 링크" title="1. 데이터 흐름에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: 단방향 데이터 흐름을 적용한다. 이벤트는 상태 변경을 트리거하고 상태는 UI로 전달된다.</p>
</li>
<li>
<p><strong>MVVM</strong>: 양방향 데이터 흐름을 사용하며, 이를 통해 상태 업데이트와 UI 상호작용이 보다 자유롭게 발생할 수 있다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-boilerplate">2. Boilerplate<a href="#2-boilerplate" class="hash-link" aria-label="2. Boilerplate에 대한 직접 링크" title="2. Boilerplate에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: 이벤트, 상태, Bloc 클래스 정의를 포함한 더 많은 보일러플레이트가 필요하다.</p>
</li>
<li>
<p><strong>MVVM</strong>: <code>notifyListeners()</code> 혹은 <code>ValueNotifier.value</code>를 통해 직접 업데이트하도록 하여 최소한의 보일러플레이트만 사용한다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-성능">3. 성능<a href="#3-성능" class="hash-link" aria-label="3. 성능에 대한 직접 링크" title="3. 성능에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: 스트림은 복잡한 비동기 작업을 처리하는데 매우 효율적이다.</p>
</li>
<li>
<p><strong>MVVM</strong>: 가볍고 빠르지만 더 크고 복잡한 애플리케이션에서는 어려움을 겪을 수 있다.</p>
<blockquote>
<p>이 부분은 아마도 원 작자가 양방향 데이터 흐름 때문에 위와 같이 설명한 것 같다. FrontEnd에서 이미 <code>Angular</code>나 <code>MobX</code>를 통해 양방향 데이터 흐름이 크고 복잡한 애플리케이션에서 얼마나 까다로운지 많은 개발자들이 경험해봤다.</p>
</blockquote>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-learning-curve">4. Learning Curve<a href="#4-learning-curve" class="hash-link" aria-label="4. Learning Curve에 대한 직접 링크" title="4. Learning Curve에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: Streams 및 StreamControllers와 같은 반응형 프로그래밍 개념을 활용하여 배우기 어렵다.</p>
</li>
<li>
<p><strong>MVVM</strong>: 메서드 혹은 변수에 직접 접근할 수 있어 보다 배우기 쉽다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-테스트">5. 테스트<a href="#5-테스트" class="hash-link" aria-label="5. 테스트에 대한 직접 링크" title="5. 테스트에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: 뛰어난 테스트 기본 기능을 제공하므로 상태 전환을 독립적으로 테스트 할 수 있다.</p>
</li>
<li>
<p><strong>MVVM</strong>: BLoC에 비해서는 테스트하기 까다롭고 UI에서 비즈니스로직을 분리하기 위해 추가 작업이 필요하다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="6-확장성">6. 확장성<a href="#6-확장성" class="hash-link" aria-label="6. 확장성에 대한 직접 링크" title="6. 확장성에 대한 직접 링크" translate="no">​</a></h4>
<ul>
<li>
<p><strong>BLoC</strong>: 공유 상태를 가지는 크고 복잡한 앱에 이상적이다.</p>
</li>
<li>
<p><strong>MVVM</strong>: 대규모 앱에서는 커플링이 발생할 수 있으므로 중소규모의 앱에 적합하다.</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="정리">정리<a href="#정리" class="hash-link" aria-label="정리에 대한 직접 링크" title="정리에 대한 직접 링크" translate="no">​</a></h2>
<p>BLoC과 MVVM은 모두 더 클린하게 관리하기 위해 <code>ChangeNotifier</code> 또는 <code>ValueNotifier</code>를 제공한다. 올바른 선택은 프로젝트의 크기, 복잡성, 선호하는 구조에 따라 달라진다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bloc을-선택해야하는-경우">BLoC을 선택해야하는 경우<a href="#bloc을-선택해야하는-경우" class="hash-link" aria-label="BLoC을 선택해야하는 경우에 대한 직접 링크" title="BLoC을 선택해야하는 경우에 대한 직접 링크" translate="no">​</a></h3>
<p>크고 복잡한 애플리케이션을 구축하고 엄격한 아키텍쳐 규칙과 함께 제공되는 이점을 원한다면, BLoC을 선택하라. 커플링이나 상태 관리를 더 완벽하게 다루고 싶다면 BLoC을 사용하는 것이 좋을 듯 하다. BLoC의 Events-States 패턴과 불변성은 데이터 흐름을 테스트, 디버깅하고 추적하는 것을 더 쉽게 만들어준다. 팀이 예측 가능성과 확장성을 고려한 접근 방식을 중요하게 여긴다면 BLoC이 확실한 선택이다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="notifier-기능이-있는-mvvm을-원할-경우">Notifier 기능이 있는 MVVM을 원할 경우<a href="#notifier-기능이-있는-mvvm을-원할-경우" class="hash-link" aria-label="Notifier 기능이 있는 MVVM을 원할 경우에 대한 직접 링크" title="Notifier 기능이 있는 MVVM을 원  할 경우에 대한 직접 링크" translate="no">​</a></h3>
<p>빠르게 구현하고 이해하기 쉬운 것을 찾고 있다면 MVVM이 맞을 수 있다. 소규모 프로젝트나 막 시작해서 BLoC의 모든 복잡성이 필요하지 않을 때 좋다. 설정하는 데 시간을 덜 쓰고 빠르게 반복하는 데 시간을 더 많이 할애할 수 있지만 시간이 지나면서 혼란이 생기지 않도록 규칙이 필요하다.</p>
<p>각 패턴이 추구하는 방향을 이해하면 팀의 요구 사항과 앱의 복잡성에 가장 적합한 패턴을 선택할 수 있다. 어떤 것을 선택하든 더 깨끗하고 효율적인 Flutter 코드를 작성하는데 큰 진전을 이룰 수 있다.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/flutter">flutter</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/architecture">Architecture</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/bloc">bloc</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/blog/tags/design-pattern">design pattern</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/mooyeon-choi/mooyeon-choi.github.io/tree/master/blog/2024-12-16-flutters-recommended-architecture-why-not-bloc.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/flutter-in-production"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">FlutterInProduction 내용 정리</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/how-to-run-application-on-background"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">애플리케이션을 백그라운드에서 동작시키기 위한 방법</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#소개" class="table-of-contents__link toc-highlight">소개</a></li><li><a href="#기본-사항-이해" class="table-of-contents__link toc-highlight">기본 사항 이해</a><ul><li><a href="#bloc의-주요-구성요소" class="table-of-contents__link toc-highlight">BLoC의 주요 구성요소</a></li><li><a href="#mvvm의-주요-구성요소" class="table-of-contents__link toc-highlight">MVVM의 주요 구성요소</a></li><li><a href="#주요-차이점" class="table-of-contents__link toc-highlight">주요 차이점</a></li></ul></li><li><a href="#정리" class="table-of-contents__link toc-highlight">정리</a><ul><li><a href="#bloc을-선택해야하는-경우" class="table-of-contents__link toc-highlight">BLoC을 선택해야하는 경우</a></li><li><a href="#notifier-기능이-있는-mvvm을-원할-경우" class="table-of-contents__link toc-highlight">Notifier 기능이 있는 MVVM을 원할 경우</a></li></ul></li></ul></div></div></div></div></div></div>
</body>
</html>